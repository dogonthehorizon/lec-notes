Signals
=======

Overview
--------
*   Signal is a notification to a process than an event has occurred
*   Signals in many cases considered "Software Interrupts"
*   Similar to hardware interrupts and in most cases difficult to predict when the signal arrives
*   A process with sufficient permissions can send a signal to another process
    *   Perhaps consider a thread that's sole purpose is to time things

Types of Signals
----------------
*   Hardware exception occurred (divide by 0, illegal memory access, malformed instruction)
*   The user typed a terminal special character (^C ^X etc)
*   A software event occurred. Ex. input became available on a file descriptor, terminal resized, timer went off


*   Each signal is defined as a unique (small) int starting from 1
*   Defined in <signal.h> that have symbolic names SIGXXXX
*   So ^C will trigger a SIGINT (#2) and is delivered to a process


*   Two broad categories for signals
    1.  Traditional, or standard, signals
        *   Used by the kernel to notify processes of events
        *   Generally SIG 1 - 31
    2.  Realtime signals


*   Signals are said to be generated by some event
    * Once generated, it is delivered to a process
*   If we want to prevent interruption from a signal, need to add a signal to the process' signal mask
    * Signal Mask - set of signals whose delivery is currently blocked
    * Achieved through system calls


*   What happens when a signal is delivered?
    1.  The signal is ignored (discarded by the kernel)
    2.  The process is terminated. (AKA Abnormal Process Termination)
    3.  A core dump file is generated and the process is terminated.
    4.  The process is stopped -- execution of the process is suspended
    5.  Execution of the process is resumed after previously being stopped
*   But we don't need to use the defaults, we can set the ** disposition ** of the signal to change behavior
    1.  The default action should occur. Useful to undo the change of the disposition of the signal to something other than the default
    2.  The signal is ignored. Useful for signal whose default action would terminate the process
    3.  A signal handler is executed (**** We want this one ****)
*   Notifying the kernel that a handler function should be invoked is referred to as installing or establishing a signal handler
*   It isn't possible to set disposition to terminate or dump unless it is the default.
    *   Closes approximate is to register handler to call SIGABRT, which dumps core


Examining signal status
-----------------------
*   Statuses for various signals can be determined on a per process basis
    *   Located at /proc/PID/status
* This file contains bit-mask fields that have hexadecimal signal numbers
    *   Least significant bit represents signal 1, next bit to the left signal 2, and so on


*   May be worth investigating SIGALRM
    *   Kernel generates this signal upon expiration of a real-time timer set by alarm() or settimer()

*   SIGALRM
    * Signal No: 14
    * Description: Real-time timer expired
    * Default: Signal terminates process

Changing Signal Dispositions: signal()
--------------------------------------
*   Two ways to change the disposition of a signal
    1.  signal()
        *   the original API for settingthe disposition of a signal
        *   Not portable, avoid using it if possible
    2.  sigaction()
        *   provides functionality not available in signal()
        *   preferred API for establishing a signal handler
*   signal() is actually implemented in glibc as a library function layered on top of sigaction()

```C
    #include <signal.h>

    void ( *signal(int sig, void (*handler)(int)) ) (int);
```

*   _sig_
    *   identifies the signal whose disposition we wish to change
*   _handler_
    *   address of the funciton that should be called when this signal is delivered
    *   this function returns nothing and takes one integer argument
    *   a handler therefore has the following form:

```C
    void handler (int sig) {
        /* Code for the handler */
    }
```

*   The return value of signal() is the previous disposition of the signal
    * Like _handler_, this is a pointer to a function returning nothing and taking one integer argument
    * The following code temporarily establishes a handler for a signal and then resets the disposition

```C
    void (*oldHandler)(int);

    oldHandler = signal(SIGINT, newHandler);
    if (oldHandler == SIG_ERR)
        errExit("signal");

    /* Do something else here. During this time, if SIGINT is delivered,
        newHandler will be used to handle the signal. */

    if (signal(SIGINT, oldHandler) == SIG_ER)
        errExit("signal");
```

*   It's not possible ot use signal() to retrieve the current disposition of a signal
    *   Unless you also change the disposition (but we can do this with sigaction)
*   We can make this function prototype more digestible  by using this typedef pointer

```C
    typedef void (*sighandler_t)(int);

    sighandler_t signal(int sig, sighandler_t handler);
```

*   In this way, we can specify one of the following values instead of the address of a function
    *   SIG_DFL
        *   Reset the disposition of the signal to its defalut
    *   SIG_IGN
        *   Ignore the signal


Signal Handlers
---------------
*   The invocation of a signal handler may interrupt the main program flow at any time
    *   Kernel calls the handler on the process' behalf
        * When the handler returns, execution of the program resumes at the point where it was interrupted
*   See diagram
*   While handlers can do almost anything, they should be designed to be as simple as possible
*   The following is an example of a signal handler function and a main program that uses it for SIGINT

```C
    #include <signal.h>

    static void sigHandler(int sig) {
        printf("Ouch!\n");
    }

    int main(int argc, char *argv[]) {
        int j;
        if (signal(SIGINT, sigHandler) == SIG_ERR)
            errExit("signal");

        for(j = 0; ; j++) {
            printf("%d\n", j);
            sleep(3);
        }
    }
```

Sending Signals: _kill()_
-------------------------
*   kill is used because signals used to (more often than not) terminate a given program.
```C
    #include <signal.h>

    int kill(pid_t pid, int sig);
```

*   pid argument identifies one or more processes to which the signal _sig_ is to be sent
    1.  If pid > 0, signal is sent to the process with the process ID specified by pid
    2.  If pid is == 0, signal is sent to every process in the same process group (including the process itself)
    3.  If pid < -1, the signal is sent to all processes in the process group whose ID == the absolute value of pid
    4.  If pid == -1, the signal is sent to every process for which the calling process has permission to send a signal, except _init_
*   If none of the above are matched, _kill()_ failes and sets _errno_ to ESRCH ("No such process")
*   You need proper permissions to send a signal, outlined by the following
    *   A privileged (CAP_KILL) process may send a signal to any process
    *   The _init_ process (pid 1), can be sent only signals for which it has a handler installed
    *   An unprivileged process can send a signal to another process if the real of effective id matches
        *   Allows users to send signals to set-user-id programs that they have started
    *   SIGCONT signal is treated specially. An unprivileged process may send this signal to any other process in the same session
*   See table for more information

Checking for the Existence of a Process
---------------------------------------
*   kill serves a dual purpose
    *   If the _sig_ argument is 0 (null signal), then no signal is sent
    *   Useful for error checking (can the pid, in fact, be signalled?)
    *   This does not mean the pid is sacred, OS reuses pids
*   A few other methods for checking whether a process is running
    1.  _wait()_ system call
        *   Can be employed only if the monitored process is a child of the caller
    2.  Semaphores and exclusive file locks
        *   If the process that is being monitored continuously holds a semaphore or a file lock then we can query the file lock to find the process
    3.  IPC channels (pipes and FIFOS)
        *   Setup a monitored process to hold a FD open for writing
    4.  The /proc/PID interface
* All techniques except 4 are immune to recycling of process IDs

Other Ways of Sending Signals: _raise()_ and _killpg()_
-------------------------------------------------------
*   To send a signal to onesself perform the following

```C
    #include <signal.h>

    int raise(int sig); //Returns 0 on success, or nonzero on error
```

*   In a single threaded program, a call to _raise()_ is equivalent to the kill command on itself
*   On a system that supports threads, _raise(sig)_ is implemented as

```C
    pthread_kill(pthread_self(), sig)
```

*   When a process sends itself a signal using _raise()_ the signal is delivered immediately
    *   e.g. before _raise()_ returns to the caller
*   Since _raise()_ returns after the signal is sent, and the only error that can occur is if we input an incorrect SIG, then we dont check return status

*   _killpg()_ send signal to all members of a process group

Displaying Signal Descriptions
------------------------------
*   Each signal has an associated printable description
    *   Listed in _sys\_siglist_
    *   Can refer to _sys\_siglist_[SIGPIPE] to get the description for SIGPIPE (broken pipe)
    *   _strsignal()_ is preferred method for getting descriptions
        *   Interestingly enough, this function is locale sensitive

Signal Sets
-----------
*   _sigaction()_ and _sigprocmask()_ allow a program to specify a group of signals thar are blocked by a process
*   _sigpending()_ returns a group of signals that are currently pending for a process
*   Multiple signals are represented using a data structure called a _signal set_
    *   Provided by _sigset\_t_
        *   This is a bit mask
*   _sigemptyset()_ initializes a signal set to contain no members
*   _sigfillset()_ initializes a set to contain all signals (including realtime signals)
*   *NOTE:* either _sigemptyset()_ or _sigaddset()_ must be used to initialize a signal set
    *   C doesn't init automatic variables, and the init of static variables to 0 can't be relied upon
*   After initialization, signals be added to a set using _sigaddset()_
    *   Removed using _sigdelset()_
*   _sigismember()_ used to test for membership of a set
*   glibc provides three non-standard functions to complement the above
    *   _sigandset()_ -- places the intersection of two sets into a new set
    *   _sigorset()_ -- places the union of two sets into a new set
    *   _sigisemptyset()_ -- returns true if the set contains no signals

The Signal Mask (Blocking Signal Delivery)
------------------------------------------
*   Kernel maintains a _signal mask_ for each process
    *   The signal mask is actually a per-thread attribute
*   Can add a signal to a signal mask in the following ways:
    1.  When a signal handler is invoked, the signal that caused its invocation can be automatically added to the signal mask
    2.  When a signal handler is established with sigaction(), it is possible to specify an additional set of signals that are to be blocked
    3.  The _sigprocmask()_ system call can be used at any time to explicitly add/remove signals from the signal mask
*   _sigprocmask()_ takes the following arguments to determine whether to add/remove

```C
    #include <signal.h>

    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

*   SIG_BLOCK
    *   The signals pointed to by _set_ are added to the signal mask
*   SIG_UNBLOCK
    *   The signals pointed to by _set_ are removed from the signal mask
*   SIG_SETMASK
    *   The signal set pointed to by _set_ is assigned to the signal mask

*   In each case, if the _oldset_ argument is !NULL, it points to a _sigset\_t_ buffer that is used to return the previous signal mask
*   To retrieve the signal mask without changing it, specify NULL for the _set_ argument
*   Note that signals are not queued
    *   In other words, we can only detect that a signal has occured, not how many times
    *   This is NOT the same for realtime signals (which _are_ queued)

Changing Signal Dispositions: _sigaction()_
-------------------------------------------
*   _sigaction()_ is an alternative to _signal()_ for setting disposition of a signal
    *   Allows us to retrieve disposition without changing it
    *   Allow setting of various attributes controlling precisely what happens when a signal handler is invoked
    *   More portable than signal
*   Here is the type signature for sigaction

```C
    #include <signal.h>

    //Returns 0 on success, or -1 on error
    int sigaction(int sig, const struct sigaction *act, struct sigaction *oldact);
```

*   The _sig_ argument identifies the signal whose disposition we want to retrieve or change
    *   Can be any signal except SIGKILL or SIGSTOP
*   The _act_ argument is a pointer to a structure specifying a new disposition for the signal
    *   If we only care about finding the existing disposition we can set this to NULL
*   The _oldact_ argument is a pointer to a struct of the same type and is used to return info about  the signals previous disposition
    *   If we don't care, supply NULL
*   A sigaction struct is described as follows

```C
    struct sigaction {
        void (*sa_handler)(int);    // Address of handler
        sigset_t sa_mask;           // Signals blocked during handler invocation
        int sa_flags;               // Flags controlling handler invocation
        void (*sa_restorer)(void);  // Not for applicaton use
    }
```
*   The _sa\_handler_ field is a direct mapping to the _handler_ argument for _signal()_
*   The _sa\_mask_ and _sa\_flags_ fields are interpreted only if _sa\_handler_ is the address of a signal handler
*   The _sa\_restorer_ field is used internally to ensure that on completion of a signal handler, a call is made to the special_purpose _sigreturn()_ system call
    *   An example of this can be found in glibc source: sysdeps/unix/sysv/linux/i386/sigaction.c

Waiting for a Signal: _pause()_
-------------------------------
*   _pause()_ suspends execution of the process until the call is interrupted by a signal handler

Summary
-------
*   A signal is a notification that an event has occurred
    * May be sent by kernel, another process, or itself
*   There is a range of standard signal types
*   Signal delivery is generally asynchronous
*   By default, a signal is either ignored, terminates a process, stops a running process, or restarts a stopped process
*   A process can use _signal()_ or _sigaction()_ to explicitly ignore a signal or to establish a programmer-defined signal

